<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun with Shapes | 3D Shapes</title>
    <style>
        :root {
            --primary: #FF6B6B;
            --secondary: #4ECDC4;
            --accent: #FFE66D;
            --dark: #292F36;
            --light: #F7FFF7;
            --purple: #7209B7;
            --orange: #FF9F1C;
            --teal: #2EC4B6;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
        }

        body {
            background-color: var(--light);
            color: var(--dark);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: var(--primary);
            color: white;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        nav {
            background-color: var(--secondary);
            display: flex;
            justify-content: center;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 1rem 2rem;
            font-weight: bold;
            transition: all 0.3s;
        }

        nav a.active {
            background-color: var(--accent);
            color: var(--dark);
        }

        nav a:hover {
            background-color: var(--accent);
            color: var(--dark);
            transform: translateY(-3px);
        }

        main {
            flex: 1;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2 {
            margin-bottom: 1rem;
            text-align: center;
        }

        p {
            text-align: center;
            margin-bottom: 2rem;
        }

        .shapes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 2rem;
        }

        .shape-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
            padding: 1.5rem;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            height: 280px;
        }

        .shape-container:hover {
            transform: translateY(-8px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }

        .shape-canvas {
            width: 100%;
            height: 180px;
            margin-bottom: 1.5rem;
        }

        .shape-name {
            font-weight: bold;
            font-size: 1.2rem;
            min-height: 1.5rem;
            text-align: center;
            color: var(--dark);
        }

        footer {
            background-color: var(--dark);
            color: white;
            text-align: center;
            padding: 1rem;
            margin-top: 2rem;
        }

        @media (max-width: 768px) {
            .shapes-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
                gap: 1.5rem;
            }
            
            .shape-container {
                padding: 1rem;
                height: 250px;
            }
            
            .shape-canvas {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Fun with Shapes</h1>
    </header>
    
    <nav>
        <a href="index.html">2D Shapes</a>
        <a href="3d-shapes.html" class="active">3D Shapes</a>
    </nav>
    
    <main>
        <h2>3D Shapes Gallery</h2>
        <p>Click on any shape to see its name and watch it rotate! Explore these three-dimensional wonders.</p>
        
        <div class="shapes-grid">
            <div class="shape-container" data-shape="Cube">
                <canvas class="shape-canvas" id="cube-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Pyramid">
                <canvas class="shape-canvas" id="pyramid-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Sphere">
                <canvas class="shape-canvas" id="sphere-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Cylinder">
                <canvas class="shape-canvas" id="cylinder-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Cone">
                <canvas class="shape-canvas" id="cone-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Torus">
                <canvas class="shape-canvas" id="torus-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Octahedron">
                <canvas class="shape-canvas" id="octahedron-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
            
            <div class="shape-container" data-shape="Hemisphere">
                <canvas class="shape-canvas" id="hemisphere-canvas"></canvas>
                <div class="shape-name"></div>
            </div>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 Fun with Shapes | A Delightful Shape Explorer</p>
    </footer>

    <script type="module">
        // Import Three.js from CDN
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';

        // Colors
        const colors = {
            primary: 0xFF6B6B,
            secondary: 0x4ECDC4,
            accent: 0xFFE66D,
            purple: 0x7209B7,
            orange: 0xFF9F1C,
            teal: 0x2EC4B6
        };

        // Store all scenes, cameras, renderers
        const scenes = {};
        const renderers = {};
        const animations = {};
        const rotationAxes = {}; // Track rotation axes and speeds
        
        // Function to create a basic scene
        function createScene(canvasId) {
            const canvas = document.getElementById(canvasId);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setClearColor(0xffffff, 0);
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 3, 5);
            scene.add(pointLight);
            
            // Add a second light from a different angle
            const pointLight2 = new THREE.PointLight(0xffffff, 0.4);
            pointLight2.position.set(-5, -3, 2);
            scene.add(pointLight2);
            
            return { scene, camera, renderer };
        }
        
        // Create cube
        function createCube() {
            const { scene, camera, renderer } = createScene("cube-canvas");
            
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.primary,
                shininess: 100,
                specular: 0x333333
            });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            // Slight rotation to show dimensionality
            cube.rotation.x = 0.5;
            cube.rotation.y = 0.7;
            
            // Store for animation
            scenes.cube = { scene, camera, object: cube };
            renderers.cube = renderer;
            rotationAxes.cube = { x: 0.01, y: 0.01, z: 0 };
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create a square-based pyramid (not tetrahedron)
        function createPyramid() {
            const { scene, camera, renderer } = createScene("pyramid-canvas");
            
            // Create a custom square-based pyramid geometry
            const geometry = new THREE.BufferGeometry();
            
            // Define the vertices (a base of 2x2 and height of 2)
            const vertices = new Float32Array([
                // Base (square)
                -1, -1, -1,
                 1, -1, -1,
                 1, -1,  1,
                -1, -1,  1,
                
                // Apex
                 0,  1,  0
            ]);
            
            // Define the faces
            const indices = [
                // Base (made of two triangles)
                0, 1, 2,
                0, 2, 3,
                
                // Side faces
                0, 4, 1,
                1, 4, 2,
                2, 4, 3,
                3, 4, 0
            ];
            
            // Set the vertices and faces
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            // Create the material and mesh
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.secondary,
                shininess: 100,
                specular: 0x333333,
                flatShading: true
            });
            
            const pyramid = new THREE.Mesh(geometry, material);
            pyramid.scale.set(1.2, 1.2, 1.2); // Make it a bit larger
            scene.add(pyramid);
            
            // Slight rotation to show dimensionality
            pyramid.rotation.x = 0.3;
            pyramid.rotation.y = 0.7;
            
            // Store for animation
            scenes.pyramid = { scene, camera, object: pyramid };
            renderers.pyramid = renderer;
            rotationAxes.pyramid = { x: 0.01, y: 0.01, z: 0 };
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create sphere
        function createSphere() {
            const { scene, camera, renderer } = createScene("sphere-canvas");
            
            const geometry = new THREE.SphereGeometry(1.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.purple,
                shininess: 100,
                specular: 0x333333
            });
            const sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            // Store for animation
            scenes.sphere = { scene, camera, object: sphere };
            renderers.sphere = renderer;
            rotationAxes.sphere = { x: 0.005, y: 0.01, z: 0 };
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create cylinder
        function createCylinder() {
            const { scene, camera, renderer } = createScene("cylinder-canvas");
            
            const geometry = new THREE.CylinderGeometry(1.2, 1.2, 2.5, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.accent,
                shininess: 100,
                specular: 0x333333
            });
            const cylinder = new THREE.Mesh(geometry, material);
            
            // Tilt cylinder initially to better show rotation
            cylinder.rotation.x = 0.5;
            cylinder.rotation.z = 0.3;
            
            scene.add(cylinder);
            
            // Store for animation with emphasized x rotation for visibility
            scenes.cylinder = { scene, camera, object: cylinder };
            renderers.cylinder = renderer;
            rotationAxes.cylinder = { x: 0.015, y: 0.005, z: 0.01 }; // Emphasize x rotation
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create cone
        function createCone() {
            const { scene, camera, renderer } = createScene("cone-canvas");
            
            const geometry = new THREE.ConeGeometry(1.5, 3, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.orange,
                shininess: 100,
                specular: 0x333333
            });
            const cone = new THREE.Mesh(geometry, material);
            
            // Tilt cone initially to better show rotation
            cone.rotation.x = 0.5;
            cone.rotation.z = 0.3;
            
            scene.add(cone);
            
            // Store for animation with emphasized x rotation for visibility
            scenes.cone = { scene, camera, object: cone };
            renderers.cone = renderer;
            rotationAxes.cone = { x: 0.015, y: 0.005, z: 0.01 }; // Emphasize x rotation
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create torus
        function createTorus() {
            const { scene, camera, renderer } = createScene("torus-canvas");
            
            const geometry = new THREE.TorusGeometry(1.2, 0.5, 16, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.teal,
                shininess: 100,
                specular: 0x333333
            });
            const torus = new THREE.Mesh(geometry, material);
            
            // Slight rotation to show dimensionality
            torus.rotation.x = 0.5;
            
            scene.add(torus);
            
            // Store for animation
            scenes.torus = { scene, camera, object: torus };
            renderers.torus = renderer;
            rotationAxes.torus = { x: 0.01, y: 0.01, z: 0 };
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create octahedron
        function createOctahedron() {
            const { scene, camera, renderer } = createScene("octahedron-canvas");
            
            const geometry = new THREE.OctahedronGeometry(1.5, 0);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.primary,
                shininess: 100,
                specular: 0x333333
            });
            const octahedron = new THREE.Mesh(geometry, material);
            
            // Slight rotation to show dimensionality
            octahedron.rotation.x = 0.4;
            octahedron.rotation.y = 0.4;
            
            scene.add(octahedron);
            
            // Store for animation
            scenes.octahedron = { scene, camera, object: octahedron };
            renderers.octahedron = renderer;
            rotationAxes.octahedron = { x: 0.01, y: 0.01, z: 0 };
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Create hemisphere with proper flat base
        function createHemisphere() {
            const { scene, camera, renderer } = createScene("hemisphere-canvas");
            
            // Create a group to hold both the hemisphere and its base
            const group = new THREE.Group();
            
            // Create the curved part
            const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.secondary,
                shininess: 100,
                specular: 0x333333
            });
            const hemisphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            
            // Create the flat base with a slightly larger radius to ensure no gaps
            const baseGeometry = new THREE.CircleGeometry(1.51, 32);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: colors.secondary,
                shininess: 100,
                side: THREE.DoubleSide // Visible from both sides
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Position and orient the flat base correctly
            base.rotation.x = Math.PI / 2;
            
            // Add both parts to the group
            group.add(hemisphere);
            group.add(base);
            
            // Tilt hemisphere to better show rotation
            group.rotation.x = 0.7;
            group.rotation.y = 0.3;
            group.rotation.z = 0.2;
            
            scene.add(group);
            
            // Store for animation with variety of rotations for visibility
            scenes.hemisphere = { scene, camera, object: group };
            renderers.hemisphere = renderer;
            rotationAxes.hemisphere = { x: 0.012, y: 0.008, z: 0.005 }; // Varied rotation
            
            // Initial render
            renderer.render(scene, camera);
        }
        
        // Initialize all shapes
        function initShapes() {
            createCube();
            createPyramid();
            createSphere();
            createCylinder();
            createCone();
            createTorus();
            createOctahedron();
            createHemisphere();
            
            // Add event listeners to shape containers
            document.querySelectorAll('.shape-container').forEach(container => {
                const shapeName = container.dataset.shape.toLowerCase();
                const nameElement = container.querySelector('.shape-name');
                
                container.addEventListener('click', () => {
                    // Display the name
                    nameElement.textContent = container.dataset.shape;
                    
                    // Toggle animation
                    toggleAnimation(shapeName);
                });
            });
        }
        
        // Animation function
        function animate() {
            requestAnimationFrame(animate);
            
            // Update each active animation
            Object.keys(animations).forEach(shapeName => {
                if (animations[shapeName]) {
                    const { scene, camera, object } = scenes[shapeName];
                    const axes = rotationAxes[shapeName];
                    
                    // Apply the appropriate rotation for each axis
                    object.rotation.x += axes.x;
                    object.rotation.y += axes.y;
                    object.rotation.z += axes.z;
                    
                    renderers[shapeName].render(scene, camera);
                }
            });
        }
        
        // Toggle animation for a shape
        function toggleAnimation(shapeName) {
            animations[shapeName] = !animations[shapeName];
        }
        
        // Window resize handler
        function handleResize() {
            Object.keys(renderers).forEach(shapeName => {
                const canvas = renderers[shapeName].domElement;
                const { scene, camera } = scenes[shapeName];
                
                // Update camera aspect ratio
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                
                // Update renderer size
                renderers[shapeName].setSize(canvas.clientWidth, canvas.clientHeight, false);
                renderers[shapeName].render(scene, camera);
            });
        }
        
        // Initialize everything when the page is loaded
        window.addEventListener('load', () => {
            initShapes();
            animate();
            window.addEventListener('resize', handleResize);
        });
    </script>
</body>
</html>
